import {Component, EventEmitter, Input, OnDestroy, OnInit, Output} from '@angular/core';
import {DataService} from '../../../services/data.service';
import {faCheck, faPlus, faRedo, faTimes, faTrash, faUndo} from '@fortawesome/free-solid-svg-icons';
import {MappingType, UtilityService} from '../../../services/utility.service';
import {NeMappingsType} from '../../../models/ne-mappings-type';
import {NeAspect} from '../../../models/ne-aspect';
import {NeMappingContinuous} from '../../../models/ne-mapping-continuous';
import {NeMappingDiscrete} from '../../../models/ne-mapping-discrete';
import {NeThresholdMap} from '../../../models/ne-threshold-map';
import {NeFontFace} from '../../../models/ne-font-face';
import 'cytoscape-cx2js';
import {CommonOSFontConstants, JavaLogicalFontConstants} from 'cytoscape-cx2js';
import {NeMapping} from '../../../models/ne-mapping';

@Component({
  selector: 'app-main-mappings-new-form',
  templateUrl: './main-mappings-new-form.component.html',
  styleUrls: ['./main-mappings-new-form.component.scss']
})
export class MainMappingsNewFormComponent implements OnInit, OnDestroy {
  /**
   * Icon: faPlus
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faPlus = faPlus;
  /**
   * Icon: faRedo
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faRedo = faRedo;
  /**
   * Icon: faTrash
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faTrash = faTrash;
  /**
   * Icon: faTimes
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faTimes = faTimes;
  /**
   * Icon: faUndo
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faUndo = faUndo;
  /**
   * Icon: faCheck
   * See {@link https://fontawesome.com/icons?d=gallery|Fontawesome} for further infos
   */
  faCheck = faCheck;
  /**
   * Style property to be mapped
   */
  styleProperty: string;
  /**
   * Type of map, e.g. 'nd' for discrete node mapping
   */
  mapType: string;
  /**
   * Index of a discrete mapping within the list of discrete mappings
   */
  mapId: number;

  /**
   * String containing the attribute's name which is currently used for mapping, e.g. 'Bait_Boolean'
   */
  col: string;
  /**
   * List of thresholds for a continuous mapping,
   * always containing at least 2 entries (default lowest and greatest).
   * Otherwise a continuous mapping does not make any sense.
   */
  thresholds: NeThresholdMap[];
  /**
   * List of font elements, null if a corresponding value is to be skipped.
   * On submitting the mapping needs to be parsed into a string for rendering
   */
  setFonts: NeFontFace[] = [];
  /**
   * Collection of all available fonts,
   * generated by adding {@link CommonOSFontConstants} and {@link JavaLogicalFontConstants}
   */
  availableFonts: string[];

  /**
   * Collection of styles which can be applied to all JavaLogicalFonts, see {@link JavaLogicalFontConstants}
   */
  javaFontStyles: string[];
  /**
   * True, if a mapping for this attribute-style-combination already exists.
   * In case of a passthrough mapping this is true, if a passthrough mapping for this style (not considering the data source) exists.
   * Used to disable the submit button.
   */
  alreadyExists = false;
  /**
   * To update a parent, what the user entered as style property, this needs to be emitted
   */
  @Output() stylePropertyEmitter = new EventEmitter<string>();
  /**
   * Essential attribute, determining edit view from creating a new mapping
   */
  @Input() isEdit!: boolean;
  /**
   * Typehint in a more standardised format
   */
  @Input() typeHint!: NeMappingsType;
  /**
   * Discrete mapping
   */
  @Input() mappingDiscrete: NeMappingDiscrete;
  /**
   * Continuous mapping
   */
  @Input() mappingContinuous: NeMappingContinuous;
  /**
   * Passthrough mapping
   */
  @Input() mappingPassthrough: NeMapping;
  /**
   * Aspect which is to be mapped
   */
  @Input() propertyToMap: NeAspect;

  constructor(
    public dataService: DataService,
    public utilityService: UtilityService
  ) {
  }

  ngOnInit(): void {
    this.mapType = this.utilityService.utilGetTypeLiteralByTypeHint(this.typeHint);
    // if (!this.isEdit) {
    //   // NEW MAPPING
    //
    //   if (this.typeHint.ec || this.typeHint.nc) {
    //     this.initContinuousMapping();
    //   }
    // } else {
    //   // EDIT MAPPING
    //   if (this.typeHint.nd || this.typeHint.ed) {
    //     // discrete
    //     this.styleProperty = this.mappingDiscrete.styleProperty;
    //     this.mapId = this.dataService.selectedDiscreteMapping.indexOf(this.mappingDiscrete);
    //
    //     if (this.styleProperty === 'EDGE_LABEL_FONT_FACE'
    //       || this.styleProperty === 'NODE_LABEL_FONT_FACE') {
    //       this.prefillDiscreteLabelMapping();
    //     }
    //
    //   } else {
    //     // continuous
    //     this.prefillContinuousMapping();
    //   }
    // }
    // this.availableFonts = Object.keys(CommonOSFontConstants.FONT_STACK_MAP)
    //   .concat(JavaLogicalFontConstants.FONT_FAMILY_LIST);
    //
    // this.javaFontStyles = Object.keys(JavaLogicalFontConstants.FONT_PROPERTIES_MAP);
  }

  ngOnDestroy(): void {
    this.styleProperty = null;
    this.typeHint = null;
    this.alreadyExists = false;
    this.setFonts = [];
  }

  /**
   * If the user checks the color property checkbox the color validation is enforced
   * @param b truthy value
   */
  toggleNeedsColorValidation(b: boolean): void {
    if (this.dataService.colorProperties.includes(this.styleProperty) && !b) {
      this.dataService.colorProperties = this.dataService.colorProperties.filter(x => x !== this.styleProperty);
    } else if (!this.dataService.colorProperties.includes(this.styleProperty) && b) {
      this.dataService.colorProperties.push(this.styleProperty);
    }
  }

  /**
   * Returns true, if a given property needs a color preview
   * @param property name of the given property
   */
  needsColorValidation(property: string): boolean {
    return (this.dataService.colorProperties.includes(property));
  }

  /**
   * Returns true, if a given property needs to be handled by a specific form
   * @param property name of the given property
   */
  needsFontFaceSpecificForm(property: string): boolean {
    return property === 'NODE_LABEL_FONT_FACE' || property === 'EDGE_LABEL_FONT_FACE';
  }

  /**
   * Adds a new threshold to a continuous mapping
   */
  public addNewThreshold(): void {
    this.thresholds.push({
      value: '#000000',
      propertyValue: '',
      isEditable: true
    });
  }

  /**
   * Clears all inputs for a mapping except the non-manipulatables of a continuous mapping
   */
  clearAllInputs(): void {
    if (!this.isEdit) {
      this.styleProperty = '';
      this.setFonts = Array(this.propertyToMap.values.length);
      this.emitStyleProperty();
    }

    this.alreadyExists = false;

    if (this.mappingDiscrete) {
      this.mappingDiscrete.values = [];
      this.mappingDiscrete.useValue = [];

      if (this.styleProperty === 'EDGE_LABEL_FONT_FACE'
        || this.styleProperty === 'NODE_LABEL_FONT_FACE') {

        for (let i = 0; i < this.setFonts.length; i++) {
          this.setFont(i, null);
          this.setStyle(i, null);
          this.setFonts[i].size = null;
        }
      }
    }

    if (this.mappingContinuous) {
      this.thresholds = [
        {
          value: String(this.propertyToMap.min) || null,
          propertyValue: null,
          isEditable: false
        },
        {
          value: String(this.propertyToMap.max) || null,
          propertyValue: null,
          isEditable: false
        },
      ];
      this.mappingContinuous.thresholds = this.thresholds.map(a => a.value) as unknown as number[];
      this.mappingContinuous.equals = this.thresholds.map(a => a.propertyValue);
    }

    if (this.mappingPassthrough) {
      this.mappingPassthrough.styleProperty = '';
    }

    console.log(this.thresholds);
  }

  /**
   * Submits a new continuous mapping
   */
  submitNewContinuousMapping(): void {
    // this.thresholds = this.thresholds.filter(a => this.utilityService.utilIsDefined(a.propertyValue)
    //   && this.utilityService.utilIsDefined(a.value));
    //
    // this.thresholds = this.thresholds.sort((a, b) => Number(a.value) > Number(b.value) ? 1 : -1);
    //
    // this.mappingContinuous.thresholds = this.thresholds.map(a => String(a.value)) as unknown as number[];
    // this.mappingContinuous.equals = this.thresholds.map(a => String(a.propertyValue));
    //
    // // trying
    // this.mappingContinuous.greaters = this.mappingContinuous.equals;
    // this.mappingContinuous.lowers = this.mappingContinuous.equals;
    //
    // this.dataService.addMappingContinuous(this.dataService.selectedNetwork, this.mappingContinuous, this.styleProperty, this.typeHint);
  }

  /**
   * Submits a new discrete mapping, adds CSS property to color properties managed in {@link GraphService}
   */
  submitNewDiscreteMapping(): void {

    // if (this.needsColorValidation(this.styleProperty)) {
    //   this.cleanForColorMappings();
    // }
    //
    // this.mappingDiscrete.styleProperty = this.styleProperty;
    // this.dataService.addMappingDiscrete(this.mappingDiscrete, this.typeHint);
  }

  /**
   * Submits a new mapping and distributes the requests between discrete and continuous mappings
   */
  submitNewMapping(): void {

    this.handleColorValidation();

    if (this.styleProperty === 'NODE_LABEL_FONT_FACE'
      || this.styleProperty === 'EDGE_LABEL_FONT_FACE') {
      this.handleLabelMapping();
    }

    if (this.typeHint.nd || this.typeHint.ed) {
      this.submitNewDiscreteMapping();
    } else if (this.typeHint.nc || this.typeHint.ec) {
      this.submitNewContinuousMapping();
    } else {
      this.submitNewPassthroughMapping();
    }
  }

  /**
   * Collapses the font specification stored within {@link setFonts} into strings
   */
  handleLabelMapping(): void {
    let aspect: NeAspect;
    if (this.typeHint.nd) {
      aspect = this.dataService.selectedNetwork.aspectKeyValuesNodes.find(a => a.name === this.mappingDiscrete.col);
    } else {
      aspect = this.dataService.selectedNetwork.aspectKeyValuesEdges.find(a => a.name === this.mappingDiscrete.col);
    }
    this.mappingDiscrete.keys = aspect.values;
    this.mappingDiscrete.values = [];

    for (let i = 0; i < this.setFonts.length; i++) {

      if (this.setFonts[i] && this.setFonts[i].family && this.setFonts[i].size) {
        this.mappingDiscrete.values.splice(i, 0,
          this.setFonts[i].family + ',,'
          + (this.setFonts[i].style ?? 'plain') + ',,'
          + this.setFonts[i].size);

      } else {

        this.mappingDiscrete.values.splice(i, 0, null);
        this.mappingDiscrete.useValue[i] = false;
      }
    }
  }

  /**
   * Handles color validation when submitting a new mapping
   */
  handleColorValidation(): void {

    if (this.needsColorValidation(this.styleProperty) && !this.dataService.colorProperties.includes(this.styleProperty)) {
      this.dataService.colorProperties.push(this.styleProperty);
    } else if (!this.needsColorValidation(this.styleProperty) && this.dataService.colorProperties.includes(this.styleProperty)) {
      this.dataService.colorProperties = this.dataService.colorProperties.filter(x => x !== this.styleProperty);
    }
  }

  /**
   * Edits an existing mapping
   */
  editMapping(): void {

    if (this.typeHint.nd || this.typeHint.ed) {

      if (this.styleProperty === 'NODE_LABEL_FONT_FACE'
        || this.styleProperty === 'EDGE_LABEL_PROPERTY') {
        this.handleLabelMapping();
      } else {
        this.cleanForColorMappings();
      }


      this.dataService.editMappingDiscrete(this.typeHint, this.mappingDiscrete, this.mapId);
    } else {
      this.dataService.editMappingContinuous(this.typeHint, this.thresholds);
    }
  }

  /**
   * Fetches next ID for the current mapType
   */
  getNextIdForMappingType(): string {
    switch (this.mapType) {
      case 'nd':
        return String(this.dataService.findDiscreteMappingForProperty(
          this.dataService.selectedNetwork.mappings.nodesDiscrete, this.propertyToMap))
          || String(this.dataService.selectedNetwork.mappings.nodesDiscrete.length);
      case 'nc':
        return String(this.dataService.selectedNetwork.mappings.nodesContinuous.length);
      case 'np':
        return String(this.dataService.selectedNetwork.mappings.nodesPassthrough.length);
      case 'ed':
        return String(this.dataService.findDiscreteMappingForProperty(
          this.dataService.selectedNetwork.mappings.edgesDiscrete, this.propertyToMap))
          || String(this.dataService.selectedNetwork.mappings.edgesDiscrete.length);
      case 'ec':
        return String(this.dataService.selectedNetwork.mappings.edgesContinuous.length);
      case 'ep':
        return String(this.dataService.selectedNetwork.mappings.edgesPassthrough.length);
    }
    return String(-1);
  }

  /**
   * Prefills the discrete mapping if the {@link styleProperty} is a label special case
   */
  prefillDiscreteLabelMapping(): void {

    let aspect: NeAspect;
    if (this.typeHint.nd) {
      aspect = this.dataService.selectedNetwork.aspectKeyValuesNodes.find(a => a.name === this.mappingDiscrete.col);
    } else {
      aspect = this.dataService.selectedNetwork.aspectKeyValuesEdges.find(a => a.name === this.mappingDiscrete.col);
    }

    for (let i = 0; i < aspect.values.length; i++) {
      const pointer = this.mappingDiscrete.keys.indexOf(aspect.values[i]);

      if (pointer > -1) {
        const commaSplit = this.mappingDiscrete.values[pointer].split(',');

        this.setFonts[i] = {
          family: commaSplit[0],
          style: commaSplit[1],
          size: commaSplit[2]
        };
      } else {
        this.setFonts[i] = {
          family: null,
          style: null,
          size: null
        };
      }
    }
  }

  /**
   * Prefills the continuous mapping
   */
  prefillContinuousMapping(): void {
    // this.mappingContinuous = this.dataService.selectedContinuousMapping;
    this.styleProperty = this.mappingContinuous.styleProperty;

    this.thresholds = [
      // default lower
      {
        value: this.mappingContinuous.thresholds[0] as unknown as string,
        propertyValue: this.mappingContinuous.lowers[0] as string,
        isEditable: false
      },
      // default greater
      {
        value: this.mappingContinuous.thresholds[this.mappingContinuous.thresholds.length - 1] as unknown as string,
        propertyValue: this.mappingContinuous
          .greaters[this.mappingContinuous.greaters.length - 1] as string,
        isEditable: false
      }];

    if (this.mappingContinuous.thresholds.length > 2) {
      for (let i = 1; i < this.mappingContinuous.thresholds.length - 1; i++) {
        const threshold: NeThresholdMap = {
          value: String(this.mappingContinuous.thresholds[i]),
          propertyValue: this.mappingContinuous.equals[i] as string,
          isEditable: true
        };
        this.thresholds.push(threshold);
      }
    }
  }

  /**
   * Emits the new styleProperty to parent
   */
  emitStyleProperty(): void {
    this.stylePropertyEmitter.emit(this.styleProperty);
    this.alreadyExists = false;

    if (this.typeHint.nd) {
      for (const mapping of this.dataService.selectedNetwork.mappings.nodesDiscrete) {
        if (mapping.col === this.propertyToMap.name && mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    } else if (this.typeHint.nc) {
      for (const mapping of this.dataService.selectedNetwork.mappings.nodesContinuous) {
        if (mapping.col === this.propertyToMap.name && mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    } else if (this.typeHint.np) {
      for (const mapping of this.dataService.selectedNetwork.mappings.nodesPassthrough) {
        if (mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    } else if (this.typeHint.ed) {
      for (const mapping of this.dataService.selectedNetwork.mappings.edgesDiscrete) {
        if (mapping.col === this.propertyToMap.name && mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    } else if (this.typeHint.ec) {
      for (const mapping of this.dataService.selectedNetwork.mappings.edgesContinuous) {
        if (mapping.col === this.propertyToMap.name && mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    } else if (this.typeHint.ep) {
      for (const mapping of this.dataService.selectedNetwork.mappings.edgesPassthrough) {
        if (mapping.styleProperty === this.styleProperty) {
          this.alreadyExists = true;
        }
      }
    }
  }

  /**
   * Since order cannot be guaranteed between attributes and mappings using these attributes
   * we need to explicitly fetch the index connecting the two.
   *
   * Relates to a discrete mapping. No equivalent for continuous mapping exists yet.
   *
   * @param key Name of the value for which the value is to be determined.
   */
  getIndexByKey(key: string): number {

    let keyIndex = this.mappingDiscrete.keys.indexOf(key);
    if (keyIndex === -1) {

      let aspect: NeAspect;
      if (this.typeHint.nd) {
        aspect = this.dataService.selectedNetwork.aspectKeyValuesNodes.find(a => a.name === this.mappingDiscrete.col);
      } else if (this.typeHint.ed) {
        aspect = this.dataService.selectedNetwork.aspectKeyValuesEdges.find(a => a.name === this.mappingDiscrete.col);
      }

      keyIndex = aspect.values.findIndex(a => a === key);

      if (isNaN(keyIndex) || keyIndex === -1) {
        console.log('No matching index found for key ' + key);
        return -1;
      }

      this.mappingDiscrete.keys.splice(keyIndex, 0, aspect.values[keyIndex]);
      this.mappingDiscrete.values.splice(keyIndex, 0, '');
      this.mappingDiscrete.useValue.splice(keyIndex, 0, true);

    }
    return keyIndex;
  }

  /**
   * Users may now remove a threshold if they don't want to add it to the mapping
   * @param index Points to the threshold to be removed
   */
  removeThreshold(index: number): void {
    this.thresholds.splice(index, 1);
  }

  /**
   * True, if the specified string is in {@link JavaLogicalFontConstants}'s font stack
   * @param font name of the font
   */
  isJavaLogicalFont(font: string): boolean {
    return Object.keys(JavaLogicalFontConstants.FONT_STACK_MAP).includes(font);
  }

  /**
   * Adds the specified font family to the {@link setFonts}
   * @param index element's position within {@link setFonts}
   * @param font Name of font, null is valid
   */
  setFont(index: number, font: string): void {
    if (!this.setFonts[index] || font === null) {
      this.setFonts[index] = {
        family: font,
        style: null,
        size: null
      };
    } else {
      this.setFonts[index].family = font;
    }

    if (!this.isJavaLogicalFont(font)) {
      this.setFonts[index].style = 'plain';
    }
  }

  /**
   * Adds the specified font style to the {@link setFonts}
   * @param index element's position within {@link setFonts}
   * @param style Name of style, null is valid, but will be converted to 'plain' on submit
   */
  setStyle(index: number, style: string): void {
    if (!this.setFonts[index]) {
      this.setFonts[index] = {
        family: null,
        style,
        size: null
      };
    } else {
      this.setFonts[index].style = style;

      if (style === null) {
        this.setFonts[index].size = null;
      }
    }
  }

  /**
   * Initializes a continuous mapping
   * @private
   */
  private initContinuousMapping(): void {

    // this.mappingContinuous = {
    //   useValue: [],
    //   mappingType: MappingType.continuous,
    //   chart: undefined,
    //   cleanStyleProperty: '',
    //   col: this.propertyToMap.name || '',
    //   colorGradient: [],
    //   equals: undefined,
    //   greaters: undefined,
    //
    //   isColor: false,
    //   lowers: undefined,
    //   styleProperty: '',
    //   thresholds: undefined,
    //   type: this.propertyToMap.datatype || 'string'
    // };
    //
    // this.thresholds = [
    //   {
    //     propertyValue: null,
    //     value: String(this.propertyToMap.min) || '#000000',
    //     isEditable: false
    //   },
    //   {
    //     propertyValue: null,
    //     value: String(this.propertyToMap.max) || '#000000',
    //     isEditable: false
    //   },
    // ];
  }

  /**
   * Submits a new discrete mapping, adds CSS property to color properties managed in {@link GraphService}
   */
  private submitNewPassthroughMapping(): void {
    // this.mappingPassthrough.styleProperty = this.styleProperty;
    // this.dataService.addMappingPassthrough(this.mappingPassthrough, this.typeHint);
  }

  /**
   * Removes values where the use-value-flag is false.
   * Needed for color properties, where null is not possible.
   * @private
   */
  private cleanForColorMappings(): void {
    const values = this.mappingDiscrete.values;
    const keys = this.mappingDiscrete.keys;
    this.mappingDiscrete.values = [];
    this.mappingDiscrete.keys = [];

    for (let i = 0; i < keys.length; i++) {
      if (this.mappingDiscrete.useValue[i]) {

        this.mappingDiscrete.keys.push(keys[i]);
        if (values[i] === '') {
          this.mappingDiscrete.values.push('#000000');
        } else {
          this.mappingDiscrete.values.push(values[i]);
        }
      }
    }
  }

}

